function displayImages(hImages,inputInfo,displayInfo,selectView,geoData)

% The coefficients are not precisely defined.

    global imageMatrixA imageMatrixS imageMatrixC;
    global inputCmd;
    global hSeqPlot;
    if length(inputInfo.FOV)<2
       inputInfo.FOV(2)=inputInfo.FOV; 
    end
    if inputInfo.FOV_flag==1
        inputInfo.FOV=rot90(inputInfo.FOV,2);
    end
    
    tempBool = ~isempty(inputCmd{4,1}) && strcmp(get(hSeqPlot,'Enable'),'off');
    
    imageMatrixA = rot90(padarray(squeeze(geoData(:, :, inputInfo.currentZ+displayInfo.geoDeltaZ)),[displayInfo.padAxial_X, displayInfo.padAxial_Y])); % for XY
    imageMatrixS = rot90(padarray(squeeze(geoData(inputInfo.currentX+displayInfo.geoDeltaX, :, :)),[displayInfo.padSagittal_Y, displayInfo.padSagittal_Z])); % for YZ
    imageMatrixC = rot90(padarray(squeeze(geoData(:, inputInfo.currentY+displayInfo.geoDeltaY, :)),[displayInfo.padCoronal_X, displayInfo.padCoronal_Z])); % for XZ

    axes(hImages.hAxlImage); %#ok<MAXES>
    imagesc(imageMatrixA);
    axis image off;

    axes(hImages.hSagImage); %#ok<MAXES>
    imagesc(imageMatrixS);
    axis image off;

    axes(hImages.hCrlImage); %#ok<MAXES>
    imagesc(imageMatrixC);
    axis image off;

    switch selectView
        case 1
            axes(hImages.hAxlImage);
            hImages.Axial.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padAxial_X,...
                displayInfo.imageLengthXY-(inputInfo.maxY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxY-inputInfo.minY+1],...
                'EdgeColor','r');
            hImages.Axial.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padAxial_X-3/2,...
                displayInfo.imageLengthXY-(inputInfo.ctrY++displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');
            
            if tempBool
                hImages.Axial.slice = rectangle('Visible','off');
            else                
                hImages.Axial.slice = rectangle('position',...
                    [inputInfo.ctrX+inputInfo.setX+displayInfo.geoDeltaX+displayInfo.padAxial_X-inputInfo.FOV(1)/inputInfo.widX/2,...
                    displayInfo.imageLengthXY-(inputInfo.ctrY+inputInfo.setY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1-inputInfo.FOV(2)/inputInfo.widY/2,...
                    inputInfo.FOV(1)/inputInfo.widX, inputInfo.FOV(2)/inputInfo.widY],'EdgeColor','g');
            end;

            axes(hImages.hSagImage);
            hImages.Sagittal.volume = rectangle('position',...
                [inputInfo.minY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y,...
                displayInfo.imageLengthYZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1,...
                inputInfo.maxY-inputInfo.minY+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Sagittal.center = rectangle('position',...
                [inputInfo.ctrY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-3/2,...
                displayInfo.imageLengthYZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Sagittal.slice = rectangle('Visible','off');
            else
                hImages.Sagittal.slice = rectangle('position',...
                    [inputInfo.ctrY+inputInfo.setY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-inputInfo.FOV(2)/inputInfo.widY/2,...
                    displayInfo.imageLengthYZ-(inputInfo.currentZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1-inputInfo.sliceTH/inputInfo.widZ/2,...
                    inputInfo.FOV(2)/inputInfo.widY, inputInfo.sliceTH/inputInfo.widZ],...
                    'EdgeColor','g');
            end;

            axes(hImages.hCrlImage); %#ok<MAXES>
            hImages.Coronal.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padCoronal_X,...
                displayInfo.imageLengthXZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Coronal.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-3/2,...
                displayInfo.imageLengthXZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Coronal.slice = rectangle('Visible','off');
            else
                hImages.Coronal.slice = rectangle('position',...
                [inputInfo.ctrX+inputInfo.setX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-inputInfo.FOV(1)/inputInfo.widX/2,...
                    displayInfo.imageLengthXZ-(inputInfo.currentZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-inputInfo.sliceTH/inputInfo.widZ/2,...
                    inputInfo.FOV(1)/inputInfo.widX, inputInfo.sliceTH/inputInfo.widZ],'EdgeColor','g');
            end;

        case 2
            axes(hImages.hAxlImage); %#ok<MAXES>
            hImages.Axial.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padAxial_X,...
                displayInfo.imageLengthXY-(inputInfo.maxY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxY-inputInfo.minY+1],...
                'EdgeColor','r');
            hImages.Axial.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padAxial_X-3/2,...
                displayInfo.imageLengthXY-(inputInfo.ctrY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Axial.slice = rectangle('Visible','off');
            else
                hImages.Axial.slice = rectangle('position',...
                    [inputInfo.currentX+displayInfo.geoDeltaX+displayInfo.padAxial_X-inputInfo.sliceTH/inputInfo.widX/2,...
                    displayInfo.imageLengthXY-(inputInfo.ctrY+inputInfo.setY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1-inputInfo.FOV(1)/inputInfo.widY/2,...
                    inputInfo.sliceTH/inputInfo.widX,inputInfo.FOV(1)/inputInfo.widY],...
                    'EdgeColor','g');
            end;

            axes(hImages.hSagImage); %#ok<MAXES>
            hImages.Sagittal.volume = rectangle('position',...
                [inputInfo.minY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y,...
                displayInfo.imageLengthYZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1,...
                inputInfo.maxY-inputInfo.minY+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Sagittal.center = rectangle('position',...
                [inputInfo.ctrY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-3/2,...
                displayInfo.imageLengthYZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');
            
            if tempBool
                hImages.Sagittal.slice = rectangle('Visible','off');
            else
                hImages.Sagittal.slice = rectangle('position',...
                    [inputInfo.ctrY+inputInfo.setY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-inputInfo.FOV(1)/inputInfo.widZ/2,...
                    displayInfo.imageLengthYZ-(inputInfo.ctrZ+inputInfo.setZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1-inputInfo.FOV(2)/inputInfo.widZ/2,...
                    inputInfo.FOV(1)/inputInfo.widY, inputInfo.FOV(2)/inputInfo.widZ],'EdgeColor','g');
            end;

            axes(hImages.hCrlImage); %#ok<MAXES>
            hImages.Coronal.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padCoronal_X,...
                displayInfo.imageLengthXZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Coronal.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-3/2,...
                displayInfo.imageLengthXZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Coronal.slice = rectangle('Visible','off');
            else
                hImages.Coronal.slice = rectangle('position',...
                    [inputInfo.currentX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-inputInfo.sliceTH/inputInfo.widX/2,...
                    displayInfo.imageLengthXZ-(inputInfo.ctrZ+inputInfo.setZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-inputInfo.FOV(2)/inputInfo.widZ/2,...
                    inputInfo.sliceTH/inputInfo.widX, inputInfo.FOV(2)/inputInfo.widZ],'EdgeColor','g');
            end;

        case 3
            axes(hImages.hAxlImage); %#ok<MAXES>
            hImages.Axial.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padAxial_X,...
                displayInfo.imageLengthXY-(inputInfo.maxY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+3/2,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxY-inputInfo.minY+1],...
                'EdgeColor','r');
            hImages.Axial.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padAxial_X-3/2,...
                displayInfo.imageLengthXY-(inputInfo.ctrY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1/2-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Axial.slice = rectangle('Visible','off');
            else            
                hImages.Axial.slice = rectangle('position',...
                    [inputInfo.ctrX+inputInfo.setX+displayInfo.geoDeltaX+displayInfo.padAxial_X-inputInfo.FOV(1)/inputInfo.widX/2,...
                    displayInfo.imageLengthXY-(inputInfo.currentY+displayInfo.geoDeltaY+displayInfo.padAxial_Y)+1/2-inputInfo.sliceTH/inputInfo.widX/2,...
                    inputInfo.FOV(1)/inputInfo.widX, inputInfo.sliceTH/inputInfo.widY],...
                    'EdgeColor','g');
            end;

            axes(hImages.hSagImage); %#ok<MAXES>
            hImages.Sagittal.volume = rectangle('position',...
                [inputInfo.minY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y,...
                displayInfo.imageLengthYZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1,...
                inputInfo.maxY-inputInfo.minY+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Sagittal.center = rectangle('position',...
                [inputInfo.ctrY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-3/2,...
                displayInfo.imageLengthYZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1/2-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');

            if tempBool
                hImages.Sagittal.slice = rectangle('Visible','off');
            else
                hImages.Sagittal.slice = rectangle('position',...
                    [inputInfo.currentY+displayInfo.geoDeltaY+displayInfo.padSagittal_Y-inputInfo.sliceTH/inputInfo.widX/2,...
                    displayInfo.imageLengthYZ-(inputInfo.ctrZ+inputInfo.setZ+displayInfo.geoDeltaZ+displayInfo.padSagittal_Z)+1-inputInfo.FOV(2)/inputInfo.widZ/2,...
                    inputInfo.sliceTH/inputInfo.widY,inputInfo.FOV(2)/inputInfo.widZ],...
                    'EdgeColor','g');
            end;

            axes(hImages.hCrlImage); %#ok<MAXES>
            hImages.Coronal.volume = rectangle('position',...
                [inputInfo.minX+displayInfo.geoDeltaX+displayInfo.padCoronal_X,...
                displayInfo.imageLengthXZ-(inputInfo.maxZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1,...
                inputInfo.maxX-inputInfo.minX+1, inputInfo.maxZ-inputInfo.minZ+1],...
                'EdgeColor','r');
            hImages.Coronal.center = rectangle('position',...
                [inputInfo.ctrX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-3/2,...
                displayInfo.imageLengthXZ-(inputInfo.ctrZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-3/2,...
                3, 3],'EdgeColor','y','FaceColor','y');
            
            if tempBool
                hImages.Coronal.slice = rectangle('Visible','off');
            else                
                hImages.Coronal.slice = rectangle('position',...
                    [inputInfo.ctrX+inputInfo.setX+displayInfo.geoDeltaX+displayInfo.padCoronal_X-inputInfo.FOV(1)/inputInfo.widX/2,...
                    displayInfo.imageLengthXZ-(inputInfo.ctrZ+inputInfo.setZ+displayInfo.geoDeltaZ+displayInfo.padCoronal_Z)+1-inputInfo.FOV(2)/inputInfo.widZ/2,...
                    inputInfo.FOV(1)/inputInfo.widX, inputInfo.FOV(2)/inputInfo.widZ],'EdgeColor','g');
            end;
    end;
    if inputInfo.FOV_flag==1
        inputInfo.FOV=rot90(inputInfo.FOV,2);
    end
end